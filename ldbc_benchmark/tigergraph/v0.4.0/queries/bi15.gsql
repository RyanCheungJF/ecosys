CREATE DISTRIBUTED QUERY bi15_add_weighted_edges(DATETIME startDate, DATETIME endDate) FOR GRAPH ldbc_snb SYNTAX v2 {

  MapAccum<UINT, DOUBLE> @weight;

  forums = SELECT f FROM Forum:f WHERE f.creationDate BETWEEN startDate AND endDate;

  messages =
    SELECT m
    FROM forums -(CONTAINER_OF>.<REPLY_OF*)- (Comment|Post):m;

  messages2 =
    SELECT m2
    FROM messages:m1 -(<REPLY_OF)- messages:m2 -(HAS_CREATOR>)- Person:p2
    ACCUM
      IF m1.type == "Post" THEN
        m1.@weight += (p2.id -> 1)
      ELSE
        m1.@weight += (p2.id -> 0.5)
      END;

  persons1 =
    SELECT p1
    FROM messages:m1 -(HAS_CREATOR>)- Person:p1
    ACCUM
      FOREACH (p2Id, w) IN m1.@weight DO
        p1.@weight += (p2Id -> w)
      END;

  persons2 =
    SELECT p2
    FROM persons1:p1 -(KNOWS)- Person:p2
    ACCUM
      DOUBLE weight = p1.@weight.get(p2.id) + p2.@weight.get(p1.id),
      INSERT INTO WEIGHT_DOUBLE (FROM, TO, weight) VALUES (p1 Person, p2 Person, weight);
}

CREATE DISTRIBUTED QUERY bi15_delete_weighted_edges() FOR GRAPH ldbc_snb SYNTAX v2 {
  tmp =
    SELECT v2
    FROM :v1 -(WEIGHT_DOUBLE:e)- :v2
    ACCUM DELETE (e);
}

CREATE DISTRIBUTED QUERY bi15(VERTEX<Person> person1Id, VERTEX<Person> person2Id, DATETIME startDate, DATETIME endDate) FOR GRAPH ldbc_snb SYNTAX v2 {

  TYPEDEF TUPLE <JSONARRAY personId, DOUBLE weight> RESULT;

  BagAccum<RESULT> @@midResult;
  HeapAccum<RESULT>(0, weight DESC, personId ASC) @@result;
  OrAccum @@stop;

  MapAccum<STRING, DOUBLE> @path1;
  MapAccum<STRING, DOUBLE> @path2;
  OrAccum @visited1;
  OrAccum @visited2;

  STRING jsonStr;

  start = {person1Id, person2Id};

  current =
    SELECT p
    FROM start:p
    ACCUM
      IF p == person1Id THEN p.@visited1 = TRUE, p.@path1 += ("[" -> 0.0) END,
      IF p == person2Id THEN p.@visited2 = TRUE, p.@path2 += ("]" -> 0.0) END;

  WHILE NOT @@stop AND current.size() > 0 DO
    current =
      SELECT t
      FROM current:s -(WEIGHT_DOUBLE:e)- Person:t
      WHERE (s.@visited1 AND NOT t.@visited1) OR (s.@visited2 AND NOT t.@visited2)
      ACCUM
        IF (s.@visited1 AND t.@visited2) OR (s.@visited2 AND t.@visited1) THEN
          # Meet on the edge.
          @@stop += TRUE,
          # We don't want to store the result twice.
          # Store once only for one direction.
          IF s.@visited1 AND t.@visited2 THEN
            FOREACH (p1, w1) IN s.@path1 DO
              FOREACH (p2, w2) IN t.@path2 DO
                STRING path = p1 + to_string(s.id) + ", " + to_string(t.id) + p2,
                DOUBLE weight = w1 + e.weight + w2,
                @@midResult += RESULT(parse_json_array(path), weight)
              END
            END
          END
        END,
        IF s.@visited1 THEN
          t.@visited1 = TRUE,
          FOREACH (p, w) IN s.@path1 DO
            t.@path1 += (p + to_string(s.id) + ", " -> w + e.weight)
          END
        ELSE IF s.@visited2 THEN
          t.@visited2 = TRUE,
          FOREACH (p, w) IN s.@path2 DO
            t.@path2 += (", " + to_string(s.id) + p -> e.weight + w)
          END
        END
      POST-ACCUM
        IF NOT @@stop AND t.@visited1 AND t.@visited2 THEN
          # Meet on the vertex.
          @@stop += TRUE,
          FOREACH (p1, w1) IN t.@path1 DO
            FOREACH (p2, w2) IN t.@path2 DO
              STRING path = p1 + to_string(t.id) + p2,
              DOUBLE weight = w1 + w2,
              @@midResult += RESULT(parse_json_array(path), weight)
            END
          END
        END;
  END;

  # Need the intermediate result to get the specific size of the result.
  @@result.resize(@@midResult.size());
  FOREACH r IN @@midResult DO
    @@result += r;
  END;

  PRINT @@result;
}
