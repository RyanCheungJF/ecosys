USE GRAPH ldbc_snb
SET syntax_version = "v2"
# Compute the weight 
# For SF100, bi19_add_weighted_edges takes ~1min for 2 hops, ~2m44s for 3 hops.
# NOTE the outdegree of REPLY_OF and indegress of HAS_CREATOR is 1
CREATE OR REPLACE DISTRIBUTED QUERY bi19_add_weighted_edges(VERTEX<City> city1Id, VERTEX<City> city2Id) {
  OrAccum<BOOL> @visited;
  MinAccum<VERTEX<Person>> @creator, @replyto;
  MapAccum<VERTEX<Person>, SumAccum<UINT>> @interactions;
  
  C ={city1Id,city2Id};
  S = SELECT p FROM C -(<IS_LOCATED_IN)- Person:p;
  S = SELECT p FROM S -(KNOWS*0..2)-Person:p ACCUM p.@visited += true;
  Sm = SELECT m FROM S:s -(<HAS_CREATOR)- (Comment|Post):m ACCUM m.@creator += s, m.@visited += true;
  Cm = SELECT m1 FROM Sm:m1 -(REPLY_OF>)- (Comment|Post):m2
    WHERE m2.@visited
    ACCUM m1.@replyto += m2.@creator;
  Cm = SELECT m FROM Cm:m -(HAS_CREATOR>)- Person:t
    ACCUM t.@interactions += (m.@replyto -> 1);
  tmp =
    SELECT p2
    FROM S:p1 -(KNOWS)- Person:p2
    WHERE p2.@visited
    ACCUM
      UINT totalInteractions = p1.@interactions.get(p2) + p2.@interactions.get(p1),
      IF totalInteractions > 0 THEN
        INSERT INTO WEIGHT_DOUBLE (FROM, TO, weight) VALUES (p1 Person, p2 Person, 1.0 / totalInteractions)
      END;
}

# DISTRIBUTED QUERY NOT SUPPORTED
CREATE OR REPLACE DISTRIBUTED QUERY bi19(VERTEX<City> city1Id, VERTEX<City> city2Id) {
  TYPEDEF TUPLE <UINT person1Id, UINT person2Id, DOUBLE totalWeight> RESULT;
  HeapAccum<RESULT>(20, totalWeight ASC, person1Id ASC, person2Id ASC) @@result;
  GroupByAccum<UINT p1, UINT p2, MinAccum<DOUBLE> dist> @@paths;
  MapAccum<UINT, MinAccum<DOUBLE>> @dist1;  
  SumAccum<UINT> @creatorId; 
  OrAccum @next1, @isTarget;
  DOUBLE threshold;
  threshold = 8; # Max path length is 8

  city1 = {city1Id};
  city2 = {city2Id};
  S = SELECT p FROM city1:c -(<IS_LOCATED_IN)- Person:p ACCUM p.@dist1 += (p.id->0);
  S2 = SELECT p FROM city2:c -(<IS_LOCATED_IN)- Person:p ACCUM p.@isTarget += True;
  
  WHILE S.size()>0 DO
    # Expand the know map, we also neglect the distances larger than threshold
    S = SELECT t FROM S:s-(WEIGHT_DOUBLE:e)-Person:t 
      ACCUM
        FOREACH (p,dis) IN s.@dist1 DO
          DOUBLE t_dis = dis + e.weight, 
          IF t_dis < threshold AND t_dis < t.@dist1.get(p) THEN
            t.@dist1 += (p -> t_dis),
            t.@next1 += true, 
            IF t.@isTarget THEN
              @@paths += (p, t.id->t_dis)
            END 
          END
        END
      HAVING t.@next1;
    S = SELECT s FROM S:s ACCUM s.@next1 = false;

    # Update the threshold
    IF S.size()>0 AND @@paths.size() >= 20 THEN
      @@result.clear();
      FOREACH (p1,p2,dist) IN @@paths DO
        @@result += RESULT(p1,p2,dist);
      END;
      FOREACH i IN RANGE[0, 19] DO
        threshold = @@result.pop().totalWeight;
      END; 
    END;
    #PRINT S.size();
  END; # WHILE (S1.size()>0 OR S2.size()>0)
  FOREACH (p1,p2,dist) IN @@paths DO
    @@result += RESULT(p1,p2,dist);
  END;
  PRINT @@result;
}

CREATE OR REPLACE DISTRIBUTED QUERY bi19_delete_weighted_edges() {
  tmp =
    SELECT v2
    FROM :v1 -(WEIGHT_DOUBLE:e)- :v2
    ACCUM DELETE (e);
}


#INSTALL QUERY bi19, bi19_add_weighted_edges, bi19_delete_weighted_edges
#RUN QUERY bi19(669, 648)