USE GRAPH ldbc_snb
SET syntax_version = "v2"
/*
This is an approxmiated query, which insert WEIGHT_DOUBLE edge in a subgraph 
within a few hops from source and target and then find the cheapest paths

The edge adding is usually the bottleneck. 
More specifically, the most expensive part is the calculation of the number of replies. 
This is because the number of comments is very large.

Different level of approximation for edge adding is in bi19-AddEdge.gsql
In SF-100 (100GB) data,
bi19_mehtod1_2hop - sometimes incorrect - 4s
bi19_method1_3hop - correct - 8s
bi19_method2_3hop - correct - 8.5s
bi19_method2_5hop - correct - 50s
bi19_method2_7hop - correct - 2min44s

An exact solution is in bi19-1.gsql, it takes ~2min for SF-100 data

The current adding edge method is "bi19_add_edges_2hop" for 30TB data.
For larger data, there are more paths between source and target, and 
approximate queries are less likely to be incorrect 
*/

// approximate query "bi19_add_edges_2hop" from bi19-AddEdge.gsql
// Include all paths of lengths <= 2
// source -(KNOWS)- mid -(KNOWS)- target
CREATE OR REPLACE DISTRIBUTED QUERY bi19_add_weighted_edges(VERTEX<City> city1Id, VERTEX<City> city2Id) {
  OrAccum<BOOL> @source, @target, @selected;
  MinAccum<VERTEX<Person>> @creator, @replyto;
  MapAccum<VERTEX<Person>, SumAccum<UINT>> @replyToCount;  
  C1 = {city1Id};
  C2 = {city2Id};
  vsource = SELECT p FROM C1 -(<IS_LOCATED_IN)- Person:p ACCUM p.@source += true;
  vtarget = SELECT p FROM C2 -(<IS_LOCATED_IN)- Person:p ACCUM p.@target += true;
  S = vsource UNION vtarget;
  mid = SELECT t FROM S:s -(KNOWS)- Person:t
    WHERE NOT (t.@source) AND (NOT t.@target)  
    ACCUM t.@source += s.@source, t.@target += s.@target
    HAVING t.@source AND t.@target;
  S = S UNION mid;
  vMessages = SELECT m FROM S:s -(<HAS_CREATOR)- (Comment|Post):m 
    ACCUM m.@creator += s, m.@selected += true; // only one can be true
  
  vMessages = SELECT m2 FROM vMessages:m1 -(<REPLY_OF)- (Comment|Post):m2
    WHERE m2.@selected
    ACCUM m2.@replyto += m1.@creator;

  PersonReplied = SELECT p FROM vMessages:m -(HAS_CREATOR>)- Person:p    
    ACCUM p.@replyToCount += (m.@replyto -> 1);
  
  tmp =
    SELECT p2
    FROM PersonReplied:p1 -(KNOWS)- Person:p2
    WHERE p1.@replyToCount.get(p2)>0 OR p2.@replyToCount.get(p1)>0
    ACCUM
      INSERT INTO WEIGHT_DOUBLE (FROM, TO, weight) VALUES (p1 Person, p2 Person, 1.0 / (p1.@replyToCount.get(p2) + p2.@replyToCount.get(p1)));
}

CREATE OR REPLACE DISTRIBUTED QUERY bi19(VERTEX<City> city1Id, VERTEX<City> city2Id) {
  TYPEDEF TUPLE <UINT person1Id, UINT person2Id, DOUBLE totalWeight> RESULT;
  HeapAccum<RESULT>(20, totalWeight ASC, person1Id ASC, person2Id ASC) @@result;
  GroupByAccum<UINT p1, UINT p2, MinAccum<DOUBLE> dist> @@paths;
  MapAccum<UINT, MinAccum<DOUBLE>> @dist1;  
  SumAccum<UINT> @creatorId; 
  OrAccum @next1, @isTarget;
  DOUBLE threshold;
  P = {Person.*};
  threshold = P.size();

  city1 = {city1Id};
  city2 = {city2Id};
  S = SELECT p FROM city1:c -(<IS_LOCATED_IN)- Person:p ACCUM p.@dist1 += (p.id->0);
  S2 = SELECT p FROM city2:c -(<IS_LOCATED_IN)- Person:p ACCUM p.@isTarget += True;
  
  WHILE S.size()>0 DO
    # Expand the know map, we also neglect the distances larger than threshold
    S = SELECT t FROM S:s-(WEIGHT_DOUBLE:e)-Person:t 
      ACCUM
        FOREACH (p,dis) IN s.@dist1 DO
          DOUBLE t_dis = dis + e.weight, 
          IF t_dis < threshold AND t_dis < t.@dist1.get(p) THEN
            t.@dist1 += (p -> t_dis),
            t.@next1 += true, 
            IF t.@isTarget THEN
              @@paths += (p, t.id->t_dis)
            END 
          END
        END
      HAVING t.@next1;
    S = SELECT s FROM S:s ACCUM s.@next1 = false;

    # Update the threshold
    IF S.size()>0 AND @@paths.size() >= 20 THEN
      @@result.clear();
      FOREACH (p1,p2,dist) IN @@paths DO
        @@result += RESULT(p1,p2,dist);
      END;
      FOREACH i IN RANGE[0, 19] DO
        threshold = @@result.pop().totalWeight;
      END; 
    END;
    #PRINT S.size();
  END; # WHILE (S1.size()>0 OR S2.size()>0)
  FOREACH (p1,p2,dist) IN @@paths DO
    @@result += RESULT(p1,p2,dist);
  END;
  PRINT @@result;
}

CREATE OR REPLACE DISTRIBUTED QUERY bi19_delete_weighted_edges() {
  tmp =
    SELECT v2
    FROM :v1 -(WEIGHT_DOUBLE:e)- :v2
    ACCUM DELETE (e);
}


#INSTALL QUERY bi19, bi19_add_weighted_edges, bi19_delete_weighted_edges
#RUN QUERY bi19(669, 648)