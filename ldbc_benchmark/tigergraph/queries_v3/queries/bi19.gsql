#This query calculates the shortest weighted path between two vertex sets.
USE GRAPH ldbc_snb
SET syntax_version = "v2"
# DISTRIBUTED QUERY NOT SUPPORTED
CREATE OR REPLACE /*DISTRIBUTED*/ QUERY bi19(VERTEX<City> city1Id, VERTEX<City> city2Id) FOR GRAPH ldbc_snb SYNTAX v2 {
  TYPEDEF TUPLE <UINT person1Id, UINT person2Id, DOUBLE totalWeight> RESULT;
  HeapAccum<RESULT>(20, totalWeight ASC, person1Id ASC, person2Id ASC) @@result;
  #GroupByAccum<UINT p1, UINT p2, SumAccum<UINT> number> @@interactions;
  MapAccum<UINT, MapAccum<UINT, SumAccum<UINT>>> @@interactions;
  GroupByAccum<UINT p1, UINT p2, MinAccum<DOUBLE> dist> @@paths;
  MapAccum<UINT, MinAccum<DOUBLE>> @dist1, @dist2;  
  SumAccum<UINT> @creatorId; 
  OrAccum @@next1, @@next2, @next1, @next2;
  DOUBLE threshold;
  threshold = 10; # Max path length is 10

  city1 = {city1Id};
  city2 = {city2Id};
  S1 = SELECT p FROM city1:c -(<IS_LOCATED_IN)- Person:p ACCUM p.@dist1 += (p.id->0);
  S2 = SELECT p FROM city2:c -(<IS_LOCATED_IN)- Person:p ACCUM p.@dist2 += (p.id->0);
  S = S1 UNION S2;
  Sm = SELECT m FROM S:s -(<HAS_CREATOR)- (Comment|Post):m ACCUM m.@creatorId += s.id;  
  tmp = SELECT m1 FROM Sm:m1 -(<REPLY_OF|REPLY_OF>)- (Comment|Post):m2 
      WHERE m2.@creatorId>0
      ACCUM @@interactions += (m1.@creatorId -> (m2.@creatorId -> 1));  
        
  @@next1 = true; @@next2 = true;
  WHILE @@next1 AND @@next2 DO
    Next = SELECT t FROM S:s-(KNOWS)-Person:t WHERE t.@dist1.size() == 0 AND t.@dist2.size() == 0;
    # Compute the weight
    Nm = SELECT m FROM Next:s -(<HAS_CREATOR)- (Comment|Post):m ACCUM m.@creatorId += s.id;
    tmp = SELECT m2 FROM Nm:m2 -(<REPLY_OF|REPLY_OF>)- (Comment|Post):m1 
      WHERE m1.@creatorId>0
      ACCUM @@interactions += (m1.@creatorId -> (m2.@creatorId -> 1));  
    
    # Expand the know map, we also neglect the distances larger than threshold
    S = SELECT s FROM S:s ACCUM s.@next1 = false, s.@next2 = false ; # From the previous loop, s.@next1 and s.@next2 can be true
    S = SELECT t FROM S:s-(KNOWS)-Person:t 
      WHERE @@interactions.get(s.id).get(t.id)>0
      ACCUM
        DOUBLE edgeWeight = 1.0 / @@interactions.get(s.id).get(t.id),
        FOREACH (p,dis) IN s.@dist1 DO
          IF dis + edgeWeight < threshold AND dis + edgeWeight < t.@dist1.get(p) THEN
            t.@dist1 += (p -> dis + edgeWeight),
            t.@next1 += true
          END
        END,
        FOREACH (p,dis) IN s.@dist2 DO
          IF dis + edgeWeight < threshold AND dis + edgeWeight < t.@dist2.get(p) THEN
            t.@dist2 += (p -> dis + edgeWeight),
            t.@next2 += true
          END
        END
      HAVING t.@next1 OR t.@next2;

      # Expand the know map, we also neglect the distances larger than threshold  
      S = SELECT s FROM S:s ACCUM
        FOREACH (p1,dis1) IN s.@dist1 DO
          FOREACH (p2,dis2) IN s.@dist2 DO
            @@paths += (p1,p2 -> dis1+dis2)
          END
        END;

    # Update the threshold
    IF S.size()>0 AND @@paths.size() >= 20 THEN
      FOREACH (p1,p2,dist) IN @@paths DO
        @@result += RESULT(p1,p2,dist);
      END;
      threshold = @@result.top().totalWeight;
    END;
    
    # To continue, S must have both 
    @@next1 = false; @@next1 = false;
    S = SELECT s FROM S:s ACCUM
      CASE WHEN s.@next1 THEN @@next1 += true
      WHEN s.@next2 THEN @@next2 += true END;
  END; # WHILE (S1.size()>0 OR S2.size()>0)
  IF @@paths.size() < 20 THEN
    FOREACH (p1,p2,dist) IN @@paths DO
      @@result += RESULT(p1,p2,dist);
    END;
  END;
  PRINT @@result;
}

#INSTALL QUERY bi19
#RUN QUERY bi19(669, 648)