# generate the parameters automatically. The parameters must yield non-empty results.
USE GRAPH ldbc_snb
SET syntax_version = "v2"

CREATE OR REPLACE DISTRIBUTED QUERY gen() {
  SumAccum<UINT> @ncomment;
  SetAccum<STRING> @@country, @@tag, @@tagclass;
  V = {Country.*};
  V = SELECT v FROM V:v LIMIT 4;
  V = SELECT v FROM V:v ACCUM @@country += v.name; 
  V = {TagClass.*};
  V = SELECT v FROM V:v LIMIT 3;
  V = SELECT v FROM V:v ACCUM @@tagclass += v.name;
  T = SELECT t FROM Tag:t
    ACCUM t.@ncomment += t.outdegree("HAS_TAG_REVERSE")
    HAVING t.@ncomment > 6000
    ORDER BY t.@ncomment ASC
    LIMIT 10;
  T = SELECT t FROM T:t ACCUM @@tag += t.name;
  PRINT @@country, @@tag, @@tagclass;
}

CREATE OR REPLACE DISTRIBUTED QUERY gen_bi10() {
  UINT personId, pid;
  STRING tagClass, country;
  OrAccum<BOOL> @selected;
  C = {Country.*};
  C = SELECT c FROM C:c LIMIT 1;
  C = SELECT c FROM C:c ACCUM country = c.name;
  P = SELECT p FROM C -(<IS_PART_OF)-City-(<IS_LOCATED_IN)-Person:p
    LIMIT 100;
  P = SELECT p FROM P:p ACCUM p.@selected += TRUE;
  TC = SELECT tc
      FROM P:p -(<HAS_CREATOR.HAS_TAG>.HAS_TYPE>)- TagClass:tc; 
  TC = SELECT tc FROM TC:tc LIMIT 1;
  TC = SELECT tc FROM TC:tc ACCUM tagClass = tc.name;
  P = SELECT p 
      FROM TC -(<HAS_TYPE.<HAS_TAG.HAS_CREATOR>)-Person:p
      WHERE p.@selected
      LIMIT 1;
  P = SELECT t FROM P:t ACCUM pid = t.id;
  P1 = SELECT t FROM P-(KNOWS)-Person:t
    LIMIT 1;
  P2 = SELECT t FROM P1-(KNOWS)-Person:t
    WHERE t.id != pid
    LIMIT 1;
  P2 = SELECT t FROM P2:t
    ACCUM personId = t.id;
    
  PRINT personId, country ,tagClass;
}    

CREATE OR REPLACE DISTRIBUTED QUERY gen_bi15() {
  OrAccum @flag,@visited;
  UINT person1Id, person2Id, iter; 
  P = {Person.*};
  P = SELECT p FROM P:p-(KNOWS)-Person LIMIT 1;
  S = SELECT p FROM P:p ACCUM person1Id = p.id, p.@visited+=true;
  iter = 0;
  WHILE S.size()>0 AND iter < 3 DO
    iter = iter+1;
    Next = SELECT t FROM S-(KNOWS)-Person:t WHERE NOT t.@visited ACCUM t.@flag += true;
    S = SELECT t 
      FROM S-(<HAS_CREATOR)-(Post|Comment)-(REPLY_OF>)-(Post|Comment)-(HAS_CREATOR>)-Person:t
      WHERE NOT t.@visited AND t.@flag
      ACCUM t.@visited += true
      LIMIT 100;
  END;
  S = SELECT s FROM S:s ACCUM person2Id = s.id LIMIT 1;
  PRINT person1Id, person2Id;
}

CREATE OR REPLACE DISTRIBUTED QUERY gen_bi16() {
  TYPEDEF TUPLE <INT d, INT nc> dn;
  MapAccum<INT, SumAccum<UINT>> @ncomment;
  HeapAccum<dn>(1, nc DESC, d ASC) @dateCount;  
  STRING tagA, tagB;
  DATETIME dateA, dateB;
  M = SELECT m FROM (Post|Comment):m-(HAS_TAG>)-Tag
    LIMIT 5000;
  T = SELECT t FROM M:m-(HAS_TAG>)-Tag:t
    ACCUM 
      INT d = datetime_diff(m.creationDate, to_datetime("2010-01-01 00:00:00")) / 86400,
      t.@ncomment += (d -> 1)
    POST-ACCUM FOREACH (d, num) IN t.@ncomment DO 
      t.@dateCount += dn(d,num)
      END
    ORDER BY t.@dateCount.top().nc DESC
    LIMIT 2;
  T1 = SELECT t FROM T:t 
    ORDER BY t.@dateCount.top().nc DESC, t.id ASC
    LIMIT 1;
  T = T MINUS T1;
  T2 = SELECT t FROM T:t 
    ORDER BY t.@dateCount.top().nc DESC, t.id ASC
    LIMIT 1;
  T1 = SELECT t FROM T1:t ACCUM tagA=t.name, 
    dateA = datetime_add(to_datetime("2010-01-01 00:00:00"), INTERVAL t.@dateCount.top().d DAY);
  T2 = SELECT t FROM T2:t ACCUM tagB=t.name,
    dateB = datetime_add(to_datetime("2010-01-01 00:00:00"), INTERVAL t.@dateCount.top().d DAY);
  PRINT tagA, dateA, tagB, dateB;
}

# BI 19
CREATE OR REPLACE DISTRIBUTED QUERY gen_bi19() {
  UINT iter;
  SetAccum<VERTEX<Person>> @persons; 
  SumAccum<UINT> @nperson;
  MapAccum<UINT, MapAccum<UINT, OrAccum<BOOL>>> @@interactions;
  SetAccum<VERTEX> @cities, @@cities;
  SetAccum<UINT> @@cityIds;
  SumAccum<UINT> @nknows;
  P = {Person.*};
  C = SELECT c 
    FROM City:c ACCUM c.@nperson += c.outdegree("IS_LOCATED_IN_REVERSE")
    HAVING c.@nperson > 50
    ORDER BY c.@nperson ASC
    LIMIT 5;
  P = SELECT p FROM C:c-(<IS_LOCATED_IN)- Person:p 
    ACCUM p.@cities += c
    LIMIT 1000;
  M = SELECT m 
    FROM P:p-(<HAS_CREATOR)-(Post|Comment):m
    ACCUM m.@persons+= p;
  M = SELECT m2 FROM M:m1 -(REPLY_OF>)-_:m2
    WHERE m2.@persons.size() >0 
    ACCUM m1.@persons += m2.@persons;
  M = SELECT m 
    FROM P:p-(<HAS_CREATOR)-(Post|Comment):m
    ACCUM p.@persons += m.@persons;
  iter = 0;
  WHILE iter < 2 DO
    iter = iter+1;
    P = SELECT t FROM P:s-(KNOWS)-Person:t 
      WHERE s.@persons.contains(t) OR t.@persons.contains(s)   
      ACCUM t.@cities += s.@cities
      LIMIT 100;
  END;
  P = SELECT p FROM P:p WHERE p.@cities.size() > 1 LIMIT 1;
  P = SELECT p FROM P:p ACCUM @@cities+=p.@cities;
  C = {@@cities};
  @@cities.clear();
  C = SELECT c FROM C:c ORDER BY c.@nperson LIMIT 2;
  C = SELECT c FROM C:c ACCUM @@cityIds += c.id;
  PRINT @@cityIds;
}  

CREATE OR REPLACE DISTRIBUTED QUERY gen_bi20() {
  SetAccum<VERTEX<University>> @univ;
  SetAccum<VERTEX<Person>> @connected;
  SetAccum<UINT> @source, @@person2Ids, @@exclude;
  SumAccum<UINT> @nknows, @nperson;
  OrAccum<BOOL> @selected;
  UINT iter;
  STRING company;

  U = {University.*};
  C = SELECT u 
    FROM U:u ACCUM u.@nperson += u.outdegree("STUDY_AT_REVERSE")
    ORDER BY u.@nperson ASC
    LIMIT 10;
  
  P = SELECT p
    FROM U -(<STUDY_AT)- Person:p
    LIMIT 4000;
  P = SELECT p FROM P:p ACCUM p.@selected += TRUE;
  P = SELECT s
    FROM P:s -(STUDY_AT>)- University:u -(<STUDY_AT)- _:t  
    WHERE s.id != t.id AND t.@selected 
    ACCUM s.@source += s.id,
      s.@connected += t;

  iter = 0;
  WHILE iter < 3 DO
    iter = iter+1;
    P = SELECT t FROM P:s-(KNOWS)-Person:t
      WHERE s.@connected.contains(t)
      ACCUM t.@source += s.@source;
  END;
  
  P = SELECT p FROM P:p -(KNOWS)- Person
    WHERE p.@source.size() > 2 
    ACCUM p.@nknows += 1;
  P = SELECT p FROM P:p -(WORK_AT>)-Company:c 
    ORDER BY p.@nknows
    LIMIT 1;
  P = SELECT p FROM P:p -(WORK_AT>)-Company:c ACCUM company=c.name, @@person2Ids += p.@source, @@exclude += p.id;
  @@person2Ids  =  @@person2Ids  MINUS @@exclude;
  PRINT company, @@person2Ids;
}

//INSTALL QUERY gen, gen_bi10, gen_bi15, gen_bi16, gen_bi19,gen_bi20
//RUN QUERY gen_bi19()
//INTERPRET QUERY gen()

